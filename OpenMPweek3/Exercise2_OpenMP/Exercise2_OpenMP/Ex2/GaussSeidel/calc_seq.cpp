#include "GaussSeidel.h"
#include <iomanip>
#include <cstdlib>
#include <iostream>>

using namespace std;

// Последовательная функция реализующая блочный алгоритм Гаусса-Зейделя
// Входные параметры: массиф неизвестных и краевых значений, массив правых частей, количество точек сетки по каждому направлению, точность вычислений
int Calc_seq_block(double** u, double** f, int N, double eps)
{

	double max = 0;
	double h = 1.0 / (N + 1); // Шаг сетки

	int IterCnt = 0; // Переменная хранящая количество выполненых итераций
	int BlockSize = 20; // Переменная отвечающая за размерность блока, для которого выполняется обработка
	int BlockCount; // Количество блоков

	cout << fixed << setprecision(10);

	if ((N) % BlockSize == 0) // Если количество точек по каждому из направлений сетки делится нацело на размер блока, то проводятся вычисления
	{
		BlockCount = (N) / BlockSize;
		do
		{
			IterCnt++;
			max = 0;
			for (int IBlock = 0; IBlock < BlockCount; IBlock++) // Проход по блокам по направлению i
				for (int JBlock = 0; JBlock < BlockCount; JBlock++)  // Проход по блокам по направлению j
					for (int idx = 0; idx < BlockSize; idx++) // Проход по строчкам блока
						for (int jdy = 0; jdy < BlockSize; jdy++) // Проход по столбцам блока
						{
							int i = 1 + IBlock*BlockSize + idx; // Вычисление глобального i индекса элемента
							int j = 1 + JBlock*BlockSize + jdy; // Вычисление глобального j индекса элемента
							double u0 = u[i][j];
							u[i][j] = 0.25 * (u[i - 1][j] + u[i + 1][j] // Расчет в соотвествии с формулами Гаусса-Зейделя
								+ u[i][j - 1] + u[i][j + 1] - h * h * f[i - 1][j - 1]);
							double d = abs(u[i][j] - u0); // Расчет модуля разности нового вычисленного значения неизвестной переменной и значения с предыдущей итераций 
							if (d > max) // Поиск максимальной ошибки
								max = d;
						}
		} while (max > eps); // Цикл выполняется до тех пор пока максимум ошибки не будет меньше заданной точности
	}
	else
	{
		cout << "Error!!!" << endl;
	}
	return IterCnt;
}

// Последовательная функция реализующая алгоритм Гаусса-Зейделя
// Входные параметры: массиф неизвестных и краевых значений, массив правых частей, количество точек сетки по каждому направлению, точность вычислений
int Calc_seq(double** u, double** f, int N, double eps)
{

	double max = 0;
	double h = 1.0 / (N + 1);
	cout << fixed << setprecision(10);

	int IterCnt = 0; // Переменная хранящая количество выполненых итераций
	do
	{
		IterCnt++;
		max = 0;
		for (int i = 1; i < N + 1; i++) // Проход по строчкам матрицы
			for (int j = 1; j < N + 1; j++) // Проход по столбцам матрицы
			{
				double u0 = u[i][j];
				u[i][j] = 0.25 * (u[i - 1][j] + u[i + 1][j] // Расчет в соотвествии с формулами Гаусса-Зейделя
					+ u[i][j - 1] + u[i][j + 1] - h * h * f[i - 1][j - 1]);
				double d = abs(u[i][j] - u0); // Расчет модуля разности нового вычисленного значения неизвестной переменной и значения с предыдущей итераций
				if (d > max) // Поиск максимальной ошибки
					max = d;
			}

	} while (max > eps); // Цикл выполняется до тех пор пока максимум ошибки не будет меньше заданной точности
	return IterCnt;
}